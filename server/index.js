/* eslint-disable no-console */

import express from 'express';
import compression from 'compression';
import { resolve as pathResolve } from 'path';
import appRootDir from 'app-root-dir';
import reactApplication from './middleware/reactApplication';
import security from './middleware/security';
import clientBundle from './middleware/clientBundle';
import serviceWorker from './middleware/serviceWorker';
import offlinePage from './middleware/offlinePage';
import errorHandlers from './middleware/errorHandlers';
import config from '../config';
var bodyParser = require('body-parser')

import pg from 'pg';
import session from 'express-session';
import passport from './middleware/passport';
import register from './middleware/register';



// Create our express based server.
const app = express();

// Don't expose any software information to potential hackers.
app.disable('x-powered-by');

// Security middlewares.
app.use(...security);

// Gzip compress the responses.
app.use(compression());

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

// Register our service worker generated by our webpack config.
// We do not want the service worker registered for development builds, and
// additionally only want it registered if the config allows.
if (process.env.BUILD_FLAG_IS_DEV === 'false' && config('serviceWorker.enabled')) {
  app.get(`/${config('serviceWorker.fileName')}`, serviceWorker);
  app.get(
    `${config('bundles.client.webPath')}${config('serviceWorker.offlinePageFileName')}`,
    offlinePage,
  );
}

// Configure serving of our client bundle.
app.use(config('bundles.client.webPath'), clientBundle);

// Configure static serving of our "public" root http path static files.
// Note: these will be served off the root (i.e. '/') of our application.
app.use(express.static(pathResolve(appRootDir.get(), config('publicAssetsPath'))));

// The React application middleware.
app.get('*', reactApplication);

//must use this instead of importing from config
var configurations = {
  user: 'postgres',
  database: 'test',
  password: '12211473',
  port: 5432,
  max: 10, // max number of connection can be open to database
  idleTimeoutMillis: 30000,
};


//database pooling
var pool = new pg.Pool(configurations);
var pgSession = require('connect-pg-simple')(session);

//TODO: fix session problems
app.use('/', session({
  store: new pgSession({
    pool : pool,                // Connection pool  // Use another table-name than the default "session" one
  }),
  secret: 'this is the secret',
  resave: false,
  saveUninitialized: false,
  expires : new Date(Date.now() + 3600000),
  cookie: { maxAge: 30 * 24 * 60 * 60 * 1000,
            httpOnly:true,
            secure: true} // 30 days
}));

app.use(passport.initialize());
app.use(passport.session()); //passport piggy backs of express sessions, still need to set express session options


/*TODO: login form alerts (i.e. wrong password), limit no. of requests for an ip
per day*/
app.post('/login', passport.authenticate('local', { //localStrategy only
        session: true,
        failureRedirect : '/login', // redirect back to the sign in page if there is an error
        failureFlash : false // allow flash messages
}), (req, res) => {
    res.redirect('/');
  },

);

//TODO: register form
app.post('/register', register);


// Error Handler middlewares.
app.use(...errorHandlers);

// Create an http listener for our express app.
const listener = app.listen(config('port'), () =>
  console.log(`Server listening on port ${config('port')}`));

// We export the listener as it will be handy for our development hot reloader,
// or for exposing a general extension layer for application customisations.
export default listener;
